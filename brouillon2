import os
import joblib
import pandas as pd
import numpy as np

# Configuration de base
current_folder = os.getcwd()
basepath = os.path.join(current_folder, "Models")

# Charger les modèles, seuils et données
model_load = joblib.load(os.path.join(basepath, "model.pkl"))
best_thresh = joblib.load(os.path.join(basepath, "best_thresh_LightGBM_NS.pkl"))
X_test = pd.read_csv(os.path.join(basepath, "X_test_sample.csv"), index_col=0)
y_test = pd.read_csv(os.path.join(basepath, "y_test_sample.csv"), index_col=0)
shap_values_ = joblib.load(os.path.join(basepath, "_shap_values_sample_.pkl"))
shap_values1 = pd.read_csv(os.path.join(basepath, "shap_values1_sample.csv"), index_col=0)
# Liste des clients à supprimer
clients_a_supprimer = [136718, 307488, 378985]

# Supprimer les clients
data = pd.DataFrame(y_test, index=y_test.index).reset_index()
data = data[~data['SK_ID_CURR'].isin(clients_a_supprimer)]

# Sauvegarder les données filtrées
data.to_csv(os.path.join(basepath, "y_test_filtered.csv"), index=False)

# Charger les colonnes
columns = joblib.load('Models/columns.pkl')

# Calculer l'importance des caractéristiques
vals = np.abs(shap_values1).mean(0)
feature_importance = pd.DataFrame(list(zip(columns, vals)), columns=['col_name', 'feature_importance_vals'])

# Définir les caractéristiques principales
top_10 = feature_importance.sort_values(by='feature_importance_vals', ascending=False)[0:10].col_name.tolist()
top_20 = feature_importance.sort_values(by='feature_importance_vals', ascending=False)[0:20].col_name.tolist()

# Afficher les résultats
#print("Top 10 Features:", top_10)
#print("Top 20 Features:", top_20)

# Assurez-vous que toutes les variables nécessaires sont définies

Client_Id = 142213  # Remplacez par un ID client valide pour le test

try:
    # Utiliser idx pour former le graph via Flask et l'importer dans Streamlit
    data_idx = data.loc[data["SK_ID_CURR"] == int(Client_Id)].index[0]  # Cela retourne un entier

    # Vérification que data_idx est dans les limites de _shap_values_
    if data_idx < len(shap_values_):
        # Customer data based on customer index in final X_test array
        ID_to_predict = pd.DataFrame(X_test.iloc[data_idx, :]).T
        
        # On réalise la prédiction de ID_to_predict avec le modèle 
        prediction = sum((model_load.predict_proba(ID_to_predict)[:, 1] > best_thresh) * 1)
        decision = "granted" if prediction == 0 else "not granted"

        # Accéder à base_values
        base_value = shap_values_[data_idx].base_values  # Accès correct

        # Afficher les résultats
        result = {
            'decision': decision,
            'base_value': base_value,
            'shap_values1_idx': shap_values1.iloc[data_idx, :].tolist(),
            "ID_to_predict": ID_to_predict.to_json(orient='columns')
        }
        print(result)  # Afficher le résultat

    else:
        print({"error": "Index out of bounds for SHAP values."})

except IndexError:
    print({"error": "Client_Id not found"})
except Exception as e:
    print({"error": str(e)})

